document.addEventListener("DOMContentLoaded", function () {
    const stage = new NGL.Stage("viewport");
    let currentComponent = null;
    let currentCIFData = null;

    // 调整视口大小
    function resizeViewport() {
        stage.handleResize();
    }

    window.addEventListener("resize", resizeViewport);

    // 解析 XYZ 数据
    function parseXYZ(xyzData) {
        const lines = xyzData.split('\n');
        const atomCount = parseInt(lines[0].trim());
        if (isNaN(atomCount)) {
            console.error("The first line is not a valid number");
            return { structureData: [], lattice: null };
        }

        let lattice = null;
        const header = lines[1].trim();
        const latticeMatch = header.match(/Lattice="([^"]+)"/);

        if (latticeMatch) {
            const latticeValues = latticeMatch[1].split(' ').map(parseFloat);
            if (latticeValues.length === 9) {
                lattice = [
                    latticeValues[0], // a
                    latticeValues[4], // b
                    latticeValues[8], // c
                    90.0,             // alpha
                    90.0,             // beta
                    90.0              // gamma
                ];
            }
        }

        const structureData = [];
        for (let i = 2; i < lines.length; i++) {
            const tokens = lines[i].trim().split(/\s+/);
            if (tokens.length === 4) {
                const element = tokens[0];
                const x = parseFloat(tokens[1]);
                const y = parseFloat(tokens[2]);
                const z = parseFloat(tokens[3]);
                if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                    structureData.push({ element, x, y, z });
                }
            }
        }

        return { structureData: structureData.slice(0, atomCount), lattice: lattice };
    }

    // 计算分子结构的边界并扩展晶格参数
    function calculateLattice(structureData) {
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

        structureData.forEach(atom => {
            if (atom.x < minX) minX = atom.x;
            if (atom.y < minY) minY = atom.y;
            if (atom.z < minZ) minZ = atom.z;
            if (atom.x > maxX) maxX = atom.x;
            if (atom.y > maxY) maxY = atom.y;
            if (atom.z > maxZ) maxZ = atom.z;
        });

        const padding = 15.0;
        const a = (maxX - minX) + padding;
        const b = (maxY - minY) + padding;
        const c = (maxZ - minZ) + padding;

        return [a, b, c, 90.0, 90.0, 90.0];
    }

    // 将 XYZ 数据转换为 CIF 格式
    function convertXYZToCIF(structureData, lattice) {
        let cifData = "data_compound\n";
        cifData += "_audit_creation_method          'generated by script'\n";

        if (!lattice) {
            lattice = calculateLattice(structureData);
        }
        
        let [a, b, c, alpha, beta, gamma] = lattice;
        cifData += `_cell_length_a                  ${a}\n`;
        cifData += `_cell_length_b                  ${b}\n`;
        cifData += `_cell_length_c                  ${c}\n`;
        cifData += `_cell_angle_alpha               ${alpha}\n`;
        cifData += `_cell_angle_beta                ${beta}\n`;
        cifData += `_cell_angle_gamma               ${gamma}\n`;

        cifData += "_symmetry_space_group_name_H-M  'P 1'\n";
        cifData += "_symmetry_Int_Tables_number     1\n";
        cifData += "loop_\n";
        cifData += "_symmetry_equiv_pos_as_xyz\n";
        cifData += "  x,y,z\n";
        cifData += "loop_\n";
        cifData += "_atom_site_label\n";
        cifData += "_atom_site_type_symbol\n";
        cifData += "_atom_site_occupancy\n";
        cifData += "_atom_site_fract_x\n";
        cifData += "_atom_site_fract_y\n";
        cifData += "_atom_site_fract_z\n";

        structureData.forEach((atom, index) => {
            let label = atom.element + (index + 1);
            let fx = (atom.x / a).toFixed(5);
            let fy = (atom.y / b).toFixed(5);
            let fz = (atom.z / c).toFixed(5);
            cifData += `${label} ${atom.element} 1.0 ${fx} ${fy} ${fz}\n`;
        });

        return cifData;
    }

    // 用选定的表示形式可视化 CIF 数据
    function visualizeCIF(representationType) {
        if (!currentCIFData) {
            return;
        }
        const cifBlob = new Blob([currentCIFData], { type: 'text/plain' });
        const cifUrl = URL.createObjectURL(cifBlob);

        stage.loadFile(cifUrl, { ext: "cif" }).then(function (component) {
            currentComponent = component;
            let params = { maxAutoBondAtoms: 10000 };
            if (representationType === 'spacefill') {
                params.radiusScale = 0.7;
            }
            component.addRepresentation(representationType, params);
            component.autoView();
            URL.revokeObjectURL(cifUrl);
        }).catch(error => {
            console.error("Error loading CIF file:", error);
        });
    }

    function clearStage() {
        stage.removeAllComponents();
    }

    window.addEventListener("message", event => {
        const message = event.data;

        if (message.command === 'loadFile') {
            clearStage();
            const xyzData = message.content;
            const { structureData, lattice } = parseXYZ(xyzData);
            if (structureData.length > 0) {
                const cifData = convertXYZToCIF(structureData, lattice);
                currentCIFData = cifData;
                console.log("Generated CIF Data:\n", cifData);
                const representationType = document.getElementById('representation-selector').value;
                visualizeCIF(representationType);
            }
        }
    });

    document.getElementById('representation-selector').addEventListener('change', function (event) {
        const representationType = event.target.value;
        if (currentComponent) {
            currentComponent.removeAllRepresentations();
            let params = { maxAutoBondAtoms: 10000 };
            if (representationType === 'spacefill') {
                params.radiusScale = 0.7;
            }
            currentComponent.addRepresentation(representationType, params);
            currentComponent.autoView();
        }
    });

    document.getElementById('reset-center-button').addEventListener('click', function () {
        if (currentComponent) {
            currentComponent.autoView();
        }
    });
});
