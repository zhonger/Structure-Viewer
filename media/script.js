document.addEventListener("DOMContentLoaded", function () {
    const stage = new NGL.Stage("viewport");
    let currentComponent = null;
    let currentCIFData = null;

    // 调整视口大小
    function resizeViewport() {
        stage.handleResize();
    }

    window.addEventListener("resize", resizeViewport);

    // 解析 XYZ 数据
    function parseXYZ(xyzData) {
        const lines = xyzData.split('\n');
        const atomCount = parseInt(lines[0].trim());
        if (isNaN(atomCount)) {
            console.error("The first line is not a valid number");
            return { structureData: [], lattice: null };
        }

        let lattice = null;
        const header = lines[1].trim();
        const latticeMatch = header.match(/Lattice="([^"]+)"/);

        if (latticeMatch) {
            const latticeValues = latticeMatch[1].split(' ').map(parseFloat);
            if (latticeValues.length === 9) {
                lattice = [
                    latticeValues[0], // a
                    latticeValues[4], // b
                    latticeValues[8], // c
                    90.0,             // alpha
                    90.0,             // beta
                    90.0              // gamma
                ];
            }
        }

        const structureData = [];
        for (let i = 2; i < lines.length; i++) {
            const tokens = lines[i].trim().split(/\s+/);
            if (tokens.length >= 4) {
                const element = tokens[0];
                const x = parseFloat(tokens[1]);
                const y = parseFloat(tokens[2]);
                const z = parseFloat(tokens[3]);
                if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                    structureData.push({ element, x, y, z });
                }
            }
        }

        return { structureData: structureData.slice(0, atomCount), lattice: lattice };
    }

    // 计算分子结构的边界并扩展晶格参数
    function calculateLattice(structureData) {
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

        structureData.forEach(atom => {
            if (atom.x < minX) minX = atom.x;
            if (atom.y < minY) minY = atom.y;
            if (atom.z < minZ) minZ = atom.z;
            if (atom.x > maxX) maxX = atom.x;
            if (atom.y > maxY) maxY = atom.y;
            if (atom.z > maxZ) maxZ = atom.z;
        });

        const padding = 15.0;
        const a = (maxX - minX) + padding;
        const b = (maxY - minY) + padding;
        const c = (maxZ - minZ) + padding;

        return [a, b, c, 90.0, 90.0, 90.0];
    }

    // 将 XYZ 数据转换为 CIF 格式
    function convertXYZToCIF(structureData, lattice) {
        let cifData = "data_compound\n";
        cifData += "_audit_creation_method          'generated by script'\n";

        if (!lattice) {
            lattice = calculateLattice(structureData);
        }

        let [a, b, c, alpha, beta, gamma] = lattice;
        cifData += `_cell_length_a                  ${a}\n`;
        cifData += `_cell_length_b                  ${b}\n`;
        cifData += `_cell_length_c                  ${c}\n`;
        cifData += `_cell_angle_alpha               ${alpha}\n`;
        cifData += `_cell_angle_beta                ${beta}\n`;
        cifData += `_cell_angle_gamma               ${gamma}\n`;

        cifData += "_symmetry_space_group_name_H-M  'P 1'\n";
        cifData += "_symmetry_Int_Tables_number     1\n";
        cifData += "loop_\n";
        cifData += "_symmetry_equiv_pos_as_xyz\n";
        cifData += "  x,y,z\n";
        cifData += "loop_\n";
        cifData += "_atom_site_label\n";
        cifData += "_atom_site_type_symbol\n";
        cifData += "_atom_site_occupancy\n";
        cifData += "_atom_site_fract_x\n";
        cifData += "_atom_site_fract_y\n";
        cifData += "_atom_site_fract_z\n";

        structureData.forEach((atom, index) => {
            let label = atom.element + (index + 1);
            let fx = (atom.x / a).toFixed(5);
            let fy = (atom.y / b).toFixed(5);
            let fz = (atom.z / c).toFixed(5);
            cifData += `${label} ${atom.element} 1.0 ${fx} ${fy} ${fz}\n`;
        });

        return cifData;
    }

    // 规范化 CIF 数据函数
    function normalizeCIF(cifData) {
        const lines = cifData.split('\n');
        const replacements = {
            "_space_group_name_H-M_alt": "_symmetry_space_group_name_H-M",
            "_space_group_IT_number": "_symmetry_Int_Tables_number",
            "_space_group_symop_operation_xyz": "_symmetry_equiv_pos_as_xyz"
        };

        let normalizedLines = [];

        const fields = {
            "_cell_length_a": null,
            "_cell_length_b": null,
            "_cell_length_c": null,
            "_cell_angle_alpha": "90.0",
            "_cell_angle_beta": "90.0",
            "_cell_angle_gamma": "90.0",
            "_symmetry_space_group_name_H-M": null,
            "_symmetry_Int_Tables_number": null
        };

        let parsedAtomSiteLoop = [];
        let atomCounter = 1;
        const uniqueAtomData = new Set();

        lines.forEach(line => {
            line = line.trim();

            // 处理 "data_       4" 变为 "data_4"
            line = line.replace(/data_\s+(\S+)/, 'data_$1');

            // 替换字段
            Object.keys(replacements).forEach(oldKey => {
                const newKey = replacements[oldKey];
                line = line.replace(oldKey, newKey);
            });

            // 检测并记录标准字段
            let fieldProcessed = false;
            for (const field in fields) {
                if (line.startsWith(field)) {
                    fields[field] = line.split(field)[1].trim();
                    fieldProcessed = true;
                    break;
                }
            }

            if (!fieldProcessed) {
                const tokens = line.split(/\s+/);

                // 检查是否为原子坐标数据
                if (tokens.length >= 5) {
                    if (tokens.length === 7) {
                        // 对调第一列和第二列的值，并删除最后一列
                        [tokens[0], tokens[1]] = [tokens[1], tokens[0]];
                        tokens.pop(); // 删除最后一列
                    }
                    if (tokens.length === 5) {
                        const element = tokens[0];
                        line = `${element}${atomCounter} ${line}`;
                        atomCounter++;
                    } else {
                        line = tokens.join(' ');
                    }
                    if (!uniqueAtomData.has(line)) {
                        uniqueAtomData.add(line);
                        parsedAtomSiteLoop.push(line);
                    }
                    return; // 跳过将原子坐标数据添加到 `normalizedLines`
                }

                // 非原子坐标数据行
                normalizedLines.push(line);
            }
        });

        // 按顺序加入字段
        let resultLines = [
            "data_compound",
            "_audit_creation_method          'generated by script'"
        ];

        for (const field in fields) {
            if (fields[field] !== null) {
                resultLines.push(`${field}               ${fields[field]}`);
            }
        }

        // 添加 _symmetry_equiv_pos_as_xyz 和 x,y,z
        resultLines.push("loop_");
        resultLines.push("_symmetry_equiv_pos_as_xyz");
        resultLines.push("  x,y,z");

        // 添加 Atom Site Loop 标头和值
        const atomSiteHeaders = [
            "_atom_site_label",
            "_atom_site_type_symbol",
            "_atom_site_occupancy",
            "_atom_site_fract_x",
            "_atom_site_fract_y",
            "_atom_site_fract_z"
        ];

        resultLines.push("loop_");
        atomSiteHeaders.forEach(header => resultLines.push(header));

        // 添加处理后的原子坐标数据
        resultLines.push(...parsedAtomSiteLoop);

        return resultLines.join('\n');
    }

    // 用选定的表示形式可视化 CIF 数据
    function visualizeCIF(representationType) {
        if (!currentCIFData) {
            return;
        }
        console.log("Current CIF Data: \n" + currentCIFData);
        const cifBlob = new Blob([currentCIFData], { type: 'text/plain' });
        const cifUrl = URL.createObjectURL(cifBlob);

        stage.loadFile(cifUrl, { ext: "cif" }).then(function (component) {
            currentComponent = component;
            let params = { maxAutoBondAtoms: 10000 };
            if (representationType === 'spacefill') {
                params.radiusScale = 0.7;
            }
            component.addRepresentation(representationType, params);
            component.autoView();
            URL.revokeObjectURL(cifUrl);
        }).catch(error => {
            console.error("Error loading CIF file:", error);
        });
    }

    function clearStage() {
        stage.removeAllComponents();
    }

    function handleXYZContent(xyzData) {
        const { structureData, lattice } = parseXYZ(xyzData);
        if (structureData.length > 0) {
            const cifData = convertXYZToCIF(structureData, lattice);
            currentCIFData = cifData;
            const representationType = document.getElementById('representation-selector').value;
            visualizeCIF(representationType);
        }
    }

    function handleCIFContent(cifData) {
        currentCIFData = normalizeCIF(cifData);
        const representationType = document.getElementById('representation-selector').value;
        visualizeCIF(representationType);
    }

    window.addEventListener("message", event => {
        const message = event.data;

        clearStage();

        if (message.command === 'loadXYZ') {
            handleXYZContent(message.content);
        } else if (message.command === 'loadCIF') {
            handleCIFContent(message.content);
        }
    });

    document.getElementById('representation-selector').addEventListener('change', function (event) {
        const representationType = event.target.value;
        if (currentComponent) {
            currentComponent.removeAllRepresentations();
            let params = { maxAutoBondAtoms: 10000 };
            if (representationType === 'spacefill') {
                params.radiusScale = 0.7;
            }
            currentComponent.addRepresentation(representationType, params);
            currentComponent.autoView();
        }
    });

    document.getElementById('reset-center-button').addEventListener('click', function () {
        if (currentComponent) {
            currentComponent.autoView();
        }
    });
});
